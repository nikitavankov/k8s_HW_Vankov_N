apiVersion: apps/v1
kind: Deployment
metadata:
  name: sqlite-backend
  namespace: nightmare-project
  labels:
    app: sqlite-backend
    project: mebn-task-manager
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sqlite-backend
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: sqlite-backend
        project: mebn-task-manager
    spec:
      initContainers:
      - name: init-database
        image: python:3.9-alpine
        command: ["sh", "-c"]
        args:
        - |
          echo "=== INITIALIZING SQLITE DATABASE ==="
          apk add --no-cache sqlite
          
          echo "Waiting for volume to be ready..."
          while [ ! -d /data ]; do
            echo "Volume not ready, sleeping..."
            sleep 2
          done
          
          echo "Creating SQLite database at /data/tasks.db..."
          sqlite3 /data/tasks.db "
          CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            description TEXT,
            status TEXT DEFAULT 'pending',
            priority TEXT DEFAULT 'medium',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
          
          INSERT OR IGNORE INTO tasks (title, description, status, priority) 
          SELECT 'Kubernetes Deployment', 'MEBN Stack on K8s', 'completed', 'high'
          WHERE NOT EXISTS (SELECT 1 FROM tasks LIMIT 1);
          
          INSERT OR IGNORE INTO tasks (title, description, status, priority) 
          SELECT 'Backend API', 'Python Flask with SQLite', 'in progress', 'high'
          WHERE (SELECT COUNT(*) FROM tasks) < 2;
          
          INSERT OR IGNORE INTO tasks (title, description, status, priority) 
          SELECT 'Frontend UI', 'Nginx web interface', 'pending', 'medium'
          WHERE (SELECT COUNT(*) FROM tasks) < 3;
          "
          
          if [ -f /data/tasks.db ]; then
            echo "✅ Database initialized successfully"
            echo "Database info:"
            sqlite3 /data/tasks.db "SELECT 'Tables:', name FROM sqlite_master WHERE type='table';"
            sqlite3 /data/tasks.db "SELECT 'Row count:', COUNT(*) FROM tasks;"
          else
            echo "❌ Database creation failed!"
            exit 1
          fi
        volumeMounts:
        - name: database-storage
          mountPath: /data
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
      
      containers:
      - name: sqlite-monitor
        image: python:3.9-alpine
        command: ["sh", "-c"]
        args:
        - |
          echo "=== SQLITE DATABASE MONITOR ==="
          apk add --no-cache sqlite
          
          health_check() {
            if [ ! -f /data/tasks.db ]; then
              echo "Database file not found"
              return 1
            fi
            
            if sqlite3 /data/tasks.db "SELECT 1;" > /dev/null 2>&1; then
              TABLES=$(sqlite3 /data/tasks.db "SELECT name FROM sqlite_master WHERE type='table' AND name='tasks';")
              if [ "$TABLES" = "tasks" ]; then
                echo "Database healthy"
                return 0
              else
                echo "Table 'tasks' not found"
                return 1
              fi
            else
              echo "Cannot query database"
              return 1
            fi
          }
          
          echo "Starting SQLite database monitor..."
          echo "Database path: /data/tasks.db"
          echo "File exists: $(test -f /data/tasks.db && echo 'YES' || echo 'NO')"
          
          while true; do
            if health_check; then
              echo "[$(date)] ✅ Database health: OK"
            else
              echo "[$(date)] ❌ Database health: FAILED"
            fi
            
            if [ -f /data/tasks.db ]; then
              SIZE=$(stat -c%s /data/tasks.db 2>/dev/null || echo 0)
              COUNT=$(sqlite3 /data/tasks.db "SELECT COUNT(*) FROM tasks;" 2>/dev/null || echo "ERROR")
              echo "[$(date)] Stats: Size=${SIZE} bytes, Rows=${COUNT}"
            fi
            
            sleep 30
          done
        volumeMounts:
        - name: database-storage
          mountPath: /data
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - test -f /data/tasks.db && sqlite3 /data/tasks.db "SELECT 1;" > /dev/null 2>&1
          initialDelaySeconds: 20
          periodSeconds: 30
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - test -f /data/tasks.db
          initialDelaySeconds: 10
          periodSeconds: 10
        resources:
          limits:
            memory: "128Mi"
            cpu: "100m"
          requests:
            memory: "64Mi"
            cpu: "50m"
      
      - name: backend
        image: python:3.9-alpine
        env:
        - name: DATABASE_FILE
          value: "/data/tasks.db"
        - name: APP_NAME
          value: "MEBN Task Manager API"
        - name: WAIT_FOR_DB
          value: "true"
        command: ["sh", "-c"]
        args:
        - |
          echo "=== MEBN BACKEND STARTING ==="
          
          if [ "$WAIT_FOR_DB" = "true" ]; then
            echo "Waiting for database to be ready..."
            MAX_WAIT=60
            count=0
            while [ ! -f /data/tasks.db ]; do
              if [ $count -ge $MAX_WAIT ]; then
                echo "❌ Timeout waiting for database file"
                exit 1
              fi
              echo "Database not ready, waiting... ($count/$MAX_WAIT)"
              sleep 2
              count=$((count + 2))
            done
            
            echo "Testing database connection..."
            if ! apk add --no-cache sqlite > /dev/null 2>&1; then
              echo "Failed to install sqlite for testing"
            elif ! sqlite3 /data/tasks.db "SELECT 1;" > /dev/null 2>&1; then
              echo "❌ Database file exists but cannot query"
              exit 1
            fi
            echo "✅ Database is ready"
          fi
          
          echo "Installing dependencies..."
          pip install flask
          
          echo "Creating Flask application with enhanced health checks..."
          cat > /app.py << 'EOF'
          from flask import Flask, request, jsonify, Response
          import sqlite3
          import os
          import time
          
          app = Flask(__name__)
          DB_FILE = os.getenv('DATABASE_FILE', '/data/tasks.db')
          
          app_status = {
              'database_connected': False,
              'last_check': None,
              'start_time': time.time()
          }
          
          def check_database_health():
              try:
                  if not os.path.exists(DB_FILE):
                      return False, "Database file not found"
                  
                  conn = sqlite3.connect(DB_FILE)
                  cursor = conn.cursor()
                  
                  cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='tasks'")
                  if not cursor.fetchone():
                      conn.close()
                      return False, "Table 'tasks' not found"
                  
                  cursor.execute("SELECT COUNT(*) FROM tasks")
                  cursor.fetchone()
                  
                  conn.close()
                  return True, "Database healthy"
              except Exception as e:
                  return False, f"Database error: {str(e)}"
          
          def get_db_connection():
              conn = sqlite3.connect(DB_FILE)
              conn.row_factory = sqlite3.Row
              return conn
          
          @app.route('/')
          def index():
              return jsonify({
                  "application": "MEBN Task Manager API",
                  "version": "1.0.0",
                  "database": "sqlite",
                  "uptime": round(time.time() - app_status['start_time'], 2),
                  "database_file": DB_FILE,
                  "database_exists": os.path.exists(DB_FILE)
              })
          
          @app.route('/health')
          def health():
              db_healthy, db_message = check_database_health()
              app_status['database_connected'] = db_healthy
              app_status['last_check'] = time.strftime("%Y-%m-%dT%H:%M:%SZ")
              
              if db_healthy:
                  try:
                      conn = get_db_connection()
                      cursor = conn.cursor()
                      cursor.execute("SELECT COUNT(*) FROM tasks")
                      count = cursor.fetchone()[0]
                      conn.close()
                      
                      return jsonify({
                          "status": "healthy",
                          "database": "sqlite",
                          "database_status": db_message,
                          "task_count": count,
                          "timestamp": app_status['last_check'],
                          "uptime_seconds": round(time.time() - app_status['start_time'], 2)
                      })
                  except Exception as e:
                      return jsonify({
                          "status": "degraded",
                          "database": "sqlite",
                          "error": str(e),
                          "timestamp": app_status['last_check']
                      }), 500
              else:
                  return jsonify({
                      "status": "unhealthy",
                      "database": "sqlite",
                      "error": db_message,
                      "timestamp": app_status['last_check']
                  }), 500
          
          @app.route('/api/health')
          def api_health():
              return health()
          
          @app.route('/api/debug')
          def debug():
              import platform
              import sys
              
              db_healthy, db_message = check_database_health()
              
              info = {
                  "python_version": sys.version,
                  "platform": platform.platform(),
                  "database": {
                      "path": DB_FILE,
                      "exists": os.path.exists(DB_FILE),
                      "size": os.path.getsize(DB_FILE) if os.path.exists(DB_FILE) else 0,
                      "healthy": db_healthy,
                      "message": db_message
                  },
                  "environment": dict(os.environ),
                  "file_system": {
                      "/data_exists": os.path.exists("/data"),
                      "/data_files": os.listdir("/data") if os.path.exists("/data") else []
                  }
              }
              
              if db_healthy:
                  try:
                      conn = get_db_connection()
                      cursor = conn.cursor()
                      cursor.execute("SELECT sql FROM sqlite_master WHERE type='table'")
                      tables = cursor.fetchall()
                      info["database"]["tables"] = [dict(t) for t in tables]
                      conn.close()
                  except Exception as e:
                      info["database"]["query_error"] = str(e)
              
              return jsonify(info)
          
          @app.route('/api/tasks', methods=['GET'])
          def get_tasks():
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("SELECT * FROM tasks ORDER BY created_at DESC")
                  rows = cursor.fetchall()
                  conn.close()
                  
                  tasks = []
                  for row in rows:
                      tasks.append(dict(row))
                  
                  return jsonify({
                      "status": "success",
                      "count": len(tasks),
                      "tasks": tasks
                  })
              except Exception as e:
                  return jsonify({"error": str(e)}), 500
          
          @app.route('/api/tasks', methods=['POST'])
          def create_task():
              try:
                  data = request.get_json()
                  if not data or 'title' not in data:
                      return jsonify({"error": "Title is required"}), 400
                  
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute(
                      "INSERT INTO tasks (title, description, status, priority) VALUES (?, ?, ?, ?)",
                      (data['title'], data.get('description', ''), data.get('status', 'pending'), data.get('priority', 'medium'))
                  )
                  conn.commit()
                  task_id = cursor.lastrowid
                  conn.close()
                  
                  return jsonify({
                      "status": "success",
                      "task_id": task_id
                  }), 201
              except Exception as e:
                  return jsonify({"error": str(e)}), 500
          
          @app.route('/api/tasks/<int:task_id>', methods=['DELETE'])
          def delete_task(task_id):
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("DELETE FROM tasks WHERE id = ?", (task_id,))
                  conn.commit()
                  deleted = cursor.rowcount > 0
                  conn.close()
                  
                  if deleted:
                      return jsonify({
                          "status": "success",
                          "message": "Task deleted successfully"
                      })
                  else:
                      return jsonify({
                          "error": "Task not found"
                      }), 404
              except Exception as e:
                  return jsonify({
                      "status": "error",
                      "message": str(e)
                  }), 500
          
          if __name__ == '__main__':
              print(f"=== MEBN BACKEND STARTING ===")
              print(f"Database file: {DB_FILE}")
              print(f"Database exists: {os.path.exists(DB_FILE)}")
              
              healthy, message = check_database_health()
              print(f"Initial database check: {healthy} - {message}")
              
              if not healthy:
                  print("⚠️ Warning: Database health check failed on startup")
                  print("Attempting to continue anyway...")
              
              print(f"Starting Flask server on 0.0.0.0:5000")
              app.run(host='0.0.0.0', port=5000, debug=False)
          EOF
          
          echo "Starting Flask server..."
          python /app.py
        ports:
        - containerPort: 5000
        volumeMounts:
        - name: database-storage
          mountPath: /data
        startupProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
          failureThreshold: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 15
          periodSeconds: 10
          failureThreshold: 3
          successThreshold: 2
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 15
          failureThreshold: 3
        resources:
          limits:
            memory: "256Mi"
            cpu: "500m"
          requests:
            memory: "128Mi"
            cpu: "250m"
      volumes:
      - name: database-storage
        emptyDir: {}