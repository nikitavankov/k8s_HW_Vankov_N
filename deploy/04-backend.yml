apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: nightmare-project
  labels:
    app: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      initContainers:
      - name: wait-for-db
        image: busybox:1.35
        command: ['sh', '-c', 'until [ -f /data/tasks.db ]; do echo "Waiting for database..."; sleep 2; done; echo "Database found!"']
        volumeMounts:
        - name: database-storage
          mountPath: /data
      containers:
      - name: backend
        image: python:3.9-alpine
        env:
        - name: DATABASE_FILE
          value: "/data/tasks.db"
        - name: APP_NAME
          value: "MEBN Task Manager API"
        - name: FLASK_ENV
          value: "production"
        command: ["sh", "-c"]
        args:
        - |
          echo "=== MEBN BACKEND DEPLOYMENT ==="
          echo "Installing Python dependencies..."
          pip install flask
          
          echo "Creating application directory..."
          mkdir -p /app
          
          echo "Writing Flask application..."
          cat > /app/main.py << 'EOF'
          from flask import Flask, request, jsonify, Response
          import sqlite3
          import os
          import time
          
          app = Flask(__name__)
          
          # Database configuration
          DB_FILE = os.getenv('DATABASE_FILE', '/data/tasks.db')
          APP_NAME = os.getenv('APP_NAME', 'MEBN Task Manager API')
          
          def get_db_connection():
              conn = sqlite3.connect(DB_FILE)
              conn.row_factory = sqlite3.Row
              return conn
          
          def init_database():
              """Initialize database if needed"""
              if not os.path.exists(DB_FILE):
                  print(f"Database file {DB_FILE} not found, creating...")
                  conn = sqlite3.connect(DB_FILE)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE tasks (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          title TEXT NOT NULL,
                          description TEXT,
                          status TEXT DEFAULT 'pending',
                          priority TEXT DEFAULT 'medium',
                          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                      )
                  ''')
                  conn.commit()
                  conn.close()
                  print("Database initialized")
          
          @app.route('/')
          def index():
              return jsonify({
                  "application": APP_NAME,
                  "version": "1.0.0",
                  "status": "running",
                  "database": "sqlite",
                  "endpoints": {
                      "health": "/health",
                      "api_health": "/api/health",
                      "tasks": "/api/tasks",
                      "create_task": "POST /api/tasks",
                      "delete_task": "DELETE /api/tasks/<id>"
                  }
              })
          
          @app.route('/health')
          def health():
              return Response("OK", status=200, mimetype='text/plain')
          
          @app.route('/api/health', methods=['GET'])
          def api_health():
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("SELECT COUNT(*) FROM tasks")
                  task_count = cursor.fetchone()[0]
                  conn.close()
                  
                  return jsonify({
                      "status": "healthy",
                      "service": "task-manager-backend",
                      "database": "sqlite",
                      "database_status": "connected",
                      "task_count": task_count,
                      "kubernetes": True,
                      "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ"),
                      "pod": os.getenv('HOSTNAME', 'unknown')
                  })
              except Exception as e:
                  return jsonify({
                      "status": "unhealthy",
                      "error": str(e)
                  }), 500
          
          @app.route('/api/tasks', methods=['GET'])
          def get_tasks():
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("SELECT * FROM tasks ORDER BY created_at DESC")
                  rows = cursor.fetchall()
                  conn.close()
                  
                  tasks = []
                  for row in rows:
                      tasks.append({
                          "id": row['id'],
                          "title": row['title'],
                          "description": row['description'],
                          "status": row['status'],
                          "priority": row['priority'],
                          "created_at": row['created_at']
                      })
                  
                  return jsonify({
                      "status": "success",
                      "count": len(tasks),
                      "tasks": tasks
                  })
              except Exception as e:
                  return jsonify({
                      "status": "error",
                      "message": str(e)
                  }), 500
          
          @app.route('/api/tasks', methods=['POST'])
          def create_task():
              try:
                  data = request.get_json()
                  if not data or 'title' not in data:
                      return jsonify({"error": "Title is required"}), 400
                  
                  title = data.get('title')
                  description = data.get('description', '')
                  status = data.get('status', 'pending')
                  priority = data.get('priority', 'medium')
                  
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute(
                      "INSERT INTO tasks (title, description, status, priority) VALUES (?, ?, ?, ?)",
                      (title, description, status, priority)
                  )
                  conn.commit()
                  task_id = cursor.lastrowid
                  conn.close()
                  
                  return jsonify({
                      "status": "success",
                      "message": "Task created successfully",
                      "task_id": task_id,
                      "task": {
                          "id": task_id,
                          "title": title,
                          "description": description,
                          "status": status,
                          "priority": priority
                      }
                  }), 201
              except Exception as e:
                  return jsonify({
                      "status": "error",
                      "message": str(e)
                  }), 500
          
          @app.route('/api/tasks/<int:task_id>', methods=['DELETE'])
          def delete_task(task_id):
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("DELETE FROM tasks WHERE id = ?", (task_id,))
                  conn.commit()
                  deleted = cursor.rowcount > 0
                  conn.close()
                  
                  if deleted:
                      return jsonify({
                          "status": "success",
                          "message": "Task deleted successfully"
                      })
                  else:
                      return jsonify({
                          "error": "Task not found"
                      }), 404
              except Exception as e:
                  return jsonify({
                      "status": "error",
                      "message": str(e)
                  }), 500
          
          if __name__ == '__main__':
              print("=== MEBN TASK MANAGER BACKEND ===")
              print(f"Application: {APP_NAME}")
              print(f"Database file: {DB_FILE}")
              print(f"Database exists: {os.path.exists(DB_FILE)}")
              print(f"Database size: {os.path.getsize(DB_FILE) if os.path.exists(DB_FILE) else 0} bytes")
              
              # Initialize database if needed
              if not os.path.exists(DB_FILE):
                  init_database()
              else:
                  print("Database already exists, skipping initialization")
              
              print("Starting Flask server on 0.0.0.0:5000")
              print("=" * 50)
              
              app.run(
                  host='0.0.0.0',
                  port=5000,
                  debug=False,
                  use_reloader=False
              )
          EOF
          
          echo "Starting backend server..."
          cd /app && python main.py
        ports:
        - containerPort: 5000
        volumeMounts:
        - name: database-storage
          mountPath: /data
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 2
          failureThreshold: 3
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 20
          periodSeconds: 10
          timeoutSeconds: 2
          failureThreshold: 3
        resources:
          limits:
            memory: "256Mi"
            cpu: "500m"
          requests:
            memory: "128Mi"
            cpu: "250m"
      volumes:
      - name: database-storage
        emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: nightmare-project
spec:
  selector:
    app: backend
  ports:
  - port: 5000
    targetPort: 5000
    protocol: TCP
  type: ClusterIP