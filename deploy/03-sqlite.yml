apiVersion: apps/v1
kind: Deployment
metadata:
  name: sqlite-backend
  namespace: nightmare-project
  labels:
    app: sqlite-backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sqlite-backend
  template:
    metadata:
      labels:
        app: sqlite-backend
    spec:
      containers:
      # ????????? 1: SQLite ???? ??????
      - name: sqlite
        image: python:3.9-alpine
        command: ["sh", "-c"]
        args:
        - |
          echo "=== SQLITE DATABASE INITIALIZATION ==="
          apk add --no-cache sqlite
          mkdir -p /data
          
          echo "Creating SQLite database..."
          sqlite3 /data/tasks.db "
          CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            description TEXT,
            status TEXT DEFAULT 'pending',
            priority TEXT DEFAULT 'medium',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
          
          INSERT OR IGNORE INTO tasks (title, description, status, priority) VALUES
          ('Kubernetes Deployment', 'MEBN Stack on K8s', 'completed', 'high'),
          ('Backend API', 'Python Flask with SQLite', 'in progress', 'high'),
          ('Frontend UI', 'Nginx web interface', 'pending', 'medium');
          "
          
          echo "Database created at /data/tasks.db"
          echo "Keeping SQLite container alive..."
          
          while true; do
            echo "[$(date)] SQLite database size: $(stat -c%s /data/tasks.db 2>/dev/null || echo 0) bytes"
            sleep 30
          done
        volumeMounts:
        - name: database-storage
          mountPath: /data
        resources:
          limits:
            memory: "128Mi"
            cpu: "100m"
          requests:
            memory: "64Mi"
            cpu: "50m"
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - test -f /data/tasks.db && sqlite3 /data/tasks.db "SELECT 1;" > /dev/null
          initialDelaySeconds: 10
          periodSeconds: 30
      
      # ????????? 2: Backend API (? ??????????? DELETE!)
      - name: backend
        image: python:3.9-alpine
        env:
        - name: DATABASE_FILE
          value: "/data/tasks.db"
        - name: APP_NAME
          value: "MEBN Task Manager API"
        command: ["sh", "-c"]
        args:
        - |
          echo "=== MEBN BACKEND STARTING ==="
          echo "Installing dependencies..."
          pip install flask
          
          echo "Creating Flask application..."
          cat > /app.py << 'EOF'
          from flask import Flask, request, jsonify, Response
          import sqlite3
          import os
          import time
          
          app = Flask(__name__)
          DB_FILE = os.getenv('DATABASE_FILE', '/data/tasks.db')
          
          def get_db_connection():
              conn = sqlite3.connect(DB_FILE)
              conn.row_factory = sqlite3.Row
              return conn
          
          @app.route('/')
          def index():
              return jsonify({
                  "application": "MEBN Task Manager API",
                  "version": "1.0.0",
                  "database": "sqlite"
              })
          
          @app.route('/health')
          def health():
              return Response("OK", status=200, mimetype='text/plain')
          
          @app.route('/api/health')
          def api_health():
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("SELECT COUNT(*) FROM tasks")
                  count = cursor.fetchone()[0]
                  conn.close()
                  return jsonify({
                      "status": "healthy",
                      "database": "sqlite",
                      "task_count": count,
                      "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ")
                  })
              except Exception as e:
                  return jsonify({"error": str(e)}), 500
          
          @app.route('/api/tasks', methods=['GET'])
          def get_tasks():
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("SELECT * FROM tasks ORDER BY created_at DESC")
                  rows = cursor.fetchall()
                  conn.close()
                  
                  tasks = []
                  for row in rows:
                      tasks.append(dict(row))
                  
                  return jsonify({
                      "status": "success",
                      "count": len(tasks),
                      "tasks": tasks
                  })
              except Exception as e:
                  return jsonify({"error": str(e)}), 500
          
          @app.route('/api/tasks', methods=['POST'])
          def create_task():
              try:
                  data = request.get_json()
                  if not data or 'title' not in data:
                      return jsonify({"error": "Title is required"}), 400
                  
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute(
                      "INSERT INTO tasks (title, description, status, priority) VALUES (?, ?, ?, ?)",
                      (data['title'], data.get('description', ''), data.get('status', 'pending'), data.get('priority', 'medium'))
                  )
                  conn.commit()
                  task_id = cursor.lastrowid
                  conn.close()
                  
                  return jsonify({
                      "status": "success",
                      "task_id": task_id
                  }), 201
              except Exception as e:
                  return jsonify({"error": str(e)}), 500
          
          @app.route('/api/tasks/<int:task_id>', methods=['DELETE'])
          def delete_task(task_id):
              try:
                  conn = get_db_connection()
                  cursor = conn.cursor()
                  cursor.execute("DELETE FROM tasks WHERE id = ?", (task_id,))
                  conn.commit()
                  deleted = cursor.rowcount > 0
                  conn.close()
                  
                  if deleted:
                      return jsonify({
                          "status": "success",
                          "message": "Task deleted successfully"
                      })
                  else:
                      return jsonify({
                          "error": "Task not found"
                      }), 404
              except Exception as e:
                  return jsonify({
                      "status": "error",
                      "message": str(e)
                  }), 500
          
          if __name__ == '__main__':
              print(f"Starting MEBN Backend with database: {DB_FILE}")
              print(f"Database exists: {os.path.exists(DB_FILE)}")
              app.run(host='0.0.0.0', port=5000, debug=False)
          EOF
          
          echo "Starting Flask server..."
          python /app.py
        ports:
        - containerPort: 5000
        volumeMounts:
        - name: database-storage
          mountPath: /data
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 15
          periodSeconds: 10
        resources:
          limits:
            memory: "256Mi"
            cpu: "500m"
          requests:
            memory: "128Mi"
            cpu: "250m"
      volumes:
      - name: database-storage
        emptyDir: {}
